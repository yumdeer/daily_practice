# 目录
@[toc]
# 前言
文章源于工作内网原因只能记录在笔记本，最近打算换个工作环境，整理下资料，简单分个类，也顺便回顾下之前的内容，也相当于做个备份。

回头看看，有些问题现在看有点简单了，但是有些问题好久没有处理也快忘了。有些地方因为是流程图，就不再用绘图软件在画了，直接拍张图片凑合看看吧。

因为基本都是之前不懂的问题，肯定文章有些错误，如有人发现也希望能够指正。<br><br>

# 版本控制
持续集成服务（Continuous Integration，CI）：只要有代码变更，就自动运行构建和测试，反馈运行结果。确保符合预期后，再将新代码集成到主干上。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210411121750279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)
## 常用git 命令
- 检查当前文件状态：git status
- 跟踪新文件：git add 文件名
- 忽略某些文件：创建`.gitignore`文件，列出要忽略的文件模式
- 提交更新：git commit -m "注释"
- 移除文件：git rm 文件名
- 查看提交历史：git log
- 检查文件修改：git diff 
- 撤销操作：git commit --amend 修改最后一次提交（比如发现漏掉文件没有加，提交信息写错了，想撤销），git reset HEAD 文件名 取消已暂存的文件，git checkout --文件名.后缀 取消对文件的修改
- 查看当前远程库：git remote -v
- 添加远程仓库：git remote add [shortname] [url]
- 从远处仓库抓取数据：git fetch [remote-name]
- 推送数据远程仓库：git push [remote-name][branch-name]
- 同步远程仓库代码：git pull
- 切换分支：git checkout 分支名 [-b] 新建 [-d] 删除

RT-Druid工具：集成OS oil文件配置，oil代码生成和编译的一个工具，可用于windows下的autosar代码开发的IDE。

<br><br>![在这里插入图片描述](https://img-blog.csdnimg.cn/20210411123212521.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)

# 操作系统
## 系统
RTOS(Real-Time Operating system)：
- 硬实时操作系统必须使任务在确定的时间内完成。
- 软实时操作系统能让绝大多数任务在确定的时间完成。

Trampoline是小型的嵌入式系统的RTOS，其API与OSEK/VDK OS和AUTOSAR OS4.2标准保持一致。

Erika Enterorise 是一个开源的OSEK/VDK内核。

### 时间管理
计算机频率的产生：[——参考文献](https://blog.csdn.net/shuibaiz/article/details/8924093)

晶体振荡器：从一块晶体上按一定的方位角切下薄片(称为"晶片")，在晶片的两个表面上涂覆一层薄薄的银层后接上一对金属板，焊接引脚，并用金属外壳封装，就构成了石英晶体振荡器。

石英晶片之所以能当为振荡器使用，是基于它的压电效应：在晶片的两个极上加一电场，会使晶体产生机械变形；在石英晶片上加上交变电压，晶体就会产生机械振动，同时机械变形振动又会产生交变电场，虽然这种交变电场的电压极其微弱，但其振动频率是十分稳定的。

可是一只石英振荡器只能提供一种频率，所以主板制造商通常将这些原本散布在主机板上各处的振荡电路整合成一颗"频率合成器(Frequency Synthesizer)"芯片，对晶体振荡器产生的脉冲信号进行分频(或倍频)，以便为不同运行速度的芯片(或设备)提供所需要的时钟频率。

**时间片**（timesilce）：又称为量子（quantum）或 处理器片（processor slice），是分时操作系统分配给每个正在运行的进程微观上的一段CPU时间（在抢占内核中是从进程开始运行知道被抢占的时间）

时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。

**时序保护**：在RTOS实时操作系统中，时序错误时有发生，即任务或中断在规定时间内未完成。如果只是简单的监测任务或中断未能在截至时间到达前结束，就判定该任务或中断引发的时序错误是不正确的。因为这只是错误被发现的最早时间点，很可能是其他任务或中断在前期阻塞太久而导致的。

为了避免上诉错误，AutoSar提供了时间保护服务，AutoSar OS是支持抢占的固定优先级操作系统任务或中断是否满足截止时间主要由下述3个因素决定：
1. 任务或中断的执行时间
2. 任务或中断由于等待访问被抢占的资源或关中断导致的阻塞时间
3. 任务或中断的间隔达到时间

相应的，AutoSar操作系统引入了三个时间预算，规定了时间上限和最小时间间隔。

### 中断
传统单片机与部分物联网硬件开发，直接跑裸机代码，主要采用下面两种编程方式：
1. 轮询模式： main() 函数死循环，不断的查询状态位（如寄存器），满足条件就去执行相应的函数，完成后继续执行main剩下的逻辑。
2. 中断模式：main函数作为主任务死循环，外部信号触发中断，打断主任务，去处理中断任务，中断任务处理完成自动回到主任务。

高并发（high Concurrency）：响应时间（response time），吞吐量（Throughput），每秒查询率QPS（Query Per Second），并发用户数。
### 内存管理
内存是现代计算机最重要的组件之一，因此它的内容不能被任何错误的应用篡改，这个功能可以通过MMU（内存管理单元）或者MPU（内存保护单元）来实现。

- MMMU负责虚拟地址到物理地址的映射，并提供硬件机制的访问权限检查。其被认为是比MPU更先进的设备，其具备MPU不具备的特性，包括缓存控制，总线仲裁，bank切换任务，由独立的MMU全权负责。但是MMU增加了额外硬件以支持虚拟内存，但将导致实时性下降。
- MPU开销更小，适合不需要做多任务或相关处理的简单系统。MPU在执行其功能时，是以所谓的`region`为单位的。一个`region`其实就是一段连续的地址，只是它们的位置和范围都要满足一些限制（对齐方式，最小容量等）。

region可以相互交迭，MPU可以根据用户的需气球，设定每个region的访问权限，避免非法的访问。kinetis的MPU使用一个成为region的描述符的寄存器组来定义每个region的访问规则和权限；一个描述符对应一个region，每个region的大小也是可编程的，且多个region是可以叠加的。kinetis最多支持12个region，每个region对应的存储空间最小为32字节，最大为4GB，且必须是32的整数倍。

Cache Memory（CPU缓存）位于CPU与内存之间的临时存储器。

内存怎么控制访问权限？
- 内存的访问权限检查决定一块内存是否允许读写。
- 这由 CP15寄存器C3(域访问控制)，描述符的域（Domain）、CP15寄存器的C1的R/S/A位，描述符的AP位共同决定域决定是否对某块内存进行权检查，“AP”决定如何对某块内存进行权限检查。

**寄存器与内存模型**：CPU本身只负责运算，不负责存储数据，数据一般存储由硬盘外存或IO等介质由总线送入主存中，CPU要用就会走主存读取数据，但CPU处理速度远高于内存的读写速度，为了避免被拖慢，CPU都自带一级/二级缓存。基本上，CPU缓存都可以看作读写速度较快的内存。

但是CPU缓存速度还不够快，另外数据在缓存中的地址是不同的，CPU每次读写都要寻址也会拖慢速度，因此，除了缓存之外，CPU还自带了寄存器，用来存储最常用的数据。也就是说，那些最频繁的数据（比如循环变量）都会放在寄存器里面，CPU优先读写寄存器，再由寄存器更内存交换数据。

但是这也引出一个问题，在多任务时，某个任务修改了某个值，寄存器中却没有更新，被其他任务取出将是个未更新的值。为了避免这个情况，关键字`Volatile`可以避免这个情况。

### Volatile
**`Volatile`**：用它声明的类型变量表示可以被某些编译器未知因素更改。用它声明的类型变量表示可以被某些编译器未知因素更改。它提醒编译器它后面定义的变量随时可以改变，因此编译后的程序每次需要存储或读取这个变量的时候，告诉编译器对该变量不做优化，都会直接从变量内存地址中读取数据，从而可以提供对特殊地址的稳定访问。

如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的进程更新了的话，将出现不一致的现象。有以下[几种情况](https://zhuanlan.zhihu.com/p/343688629)需要额外注意：
- 并行设备的硬件寄存器（如：状态寄存器）
- 中断服务程序中修改的供其它程序检测的变量
- 多任务环境下各任务间共享的标志，应该加volatile
- 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义

需要注意的是，`volatile`可以保证可见性和顺序性，不能保证操作的原子性。因为`volatile`只作用在编译器层面，处理器并不感知volatile的存在与作用。volatile并不是用来解决多线程竞争问题的，而是用来修饰一些因为程序不可控因素导致变化的变量，比如访问底层硬件设备的变量，以提醒编译器不要对该变量的访问擅自进行优化。

i++ 是否是线程安全的（原子操作）？否！因为 i++操作可以分为三步：
1. load i (i=0) 内存到寄存器
2. i++ (i=1) 寄存器自增
3. store i (i=1) 写回内存

用volatile保证原子操作，只是确保了第一步`load i`一定从存储器中读取数据。无法保障进行三步操作的过程中会不会被其他任务/中断 分离抢占（原子性）。所以使用lock或者Atomic才是唯一正确的选择。（C++11标准中明确指出解决多线程的数据竞争问题应该使用原子操作或者互斥锁。）


### 原子操作
原子（ATOM）本意是"不能被进一步分割的最小粒子"。

**原子操作（atomic operation）** 是不需要synchronized（同步）。所谓原子 操作是指不会被线程调度机制打断的操作。这种操作一旦开始，就一直运行到结束，中间不会有任何context switch（切换到另一个线程），其可能是多个操作，但不可被打断和分割。

Linux原子操作问题来源与中断、进程的抢占以及多核SMP系统中程序的并发执行。对于临界区的操作，可以加锁来保证原子性，对与全局变量或者静态变量的操作则需要依赖硬件平台的原子变量操作。

因此，原子操作有两类：一类是各种临界区的锁，一类是操作原子变量的函数。

对于ARM来说，单汇编指令都是原子的，多核SMP也是，因为有总线仲裁，所以CPU可以单独占用总线直到指令结束。

多核系统中的原子操作通常使用**内存屏障**（memory barrirer）来实现。即一个CPU核在执行原子操作时，其他CPU核必须停止对内存操作或者不对指定的内存进行操作。这样才能避免**数据竞争**问题。		但是对于`load update store`这个过程可能被中断、抢占，所以ARM指令集有增加了`Idrex / Strex` 操作实现 `load update store` 的原子操作。  

 - 在计算机领域里，如果要在多线程的情况下要保持数据的同步，需要引入称作`Load-Link（LL）`和`Store-Conditional（SC）`的操作，通常简称为`LL/SC`。`LL`操作返回一个内存地址上当前存储的值，后面的SC操作，会向这个内存地址写入一个新值，但是只有在这个内存地址上存储的值，从上个LL操作开始直到现在都没有发生改变的情况下，写入操作才能成功，否则都会失败。这个操作非常重要，是很多平台实现基本原子操作的基础。

 对于ARM平台来说，也在硬件层面上提供了对LL/SC的支持，LL操作用的是LDREX指令，SC操作用的是STREX指令。   [- 参考文章](https://blog.csdn.net/Roland_Sun/article/details/47670099)

但是Linux对于C/C++程序（一条C语言可能被编译成多条汇编），由于上诉提到的原因，不能保证原子性，因此Linux提供了一套函数来操作全局变量或静态变量。

### 架构
软件架构（体系结构）就是一个设计方案将用户的不同需求抽象成抽象件，并且能够描述这些抽象组件之间的同行和调用。

框架：框架不是架构，框架比架构更具体，更偏向技术，而架构偏向设计，架构可以通过多种框架实现。

框架可以说是一个半成品的应用，其具有针对性，内部元素之间紧密程序远远大于类库元素之间关系。
- 结构上：框架内部是高内聚的，而类库内部是相对松散的
- 功能上：框架封装了处理流程的控制逻辑，而类库几乎不涉及任何处理流程和逻辑控制
- 设计上：框架具有IOC（控制反转）能力，而类库不具备
- 对类库中的元素，通常都是由我们的应用来调用它，而框架具有这种能力——在适当的时候调用我们应用中的逻辑，这种能力是通过框架扩展点（插槽）来做到的。框架通常建立在众多类库的基础上，而类库一般不会依赖于某框架。（MFC就是一种应用程序框架，其只能在Windows上运行）
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210412220959379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421225836605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210411153909498.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)
![](https://img-blog.csdnimg.cn/20210411213808442.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)
**BSW架构：**

服务层被分为三部分：
1. 通信服务（communication Service）：将包括CAN、LIN、FlexRay在内的整车网络，ECU网络及软件组件在内的访问进行了统一封装，对上层应用软件层隐藏了协议以及报文属性。提供了统一的总线通信接口供应用软件层调用。提供了同意的网络管理接口。提供同意的诊断通信接口。
2. 内存服务（Memory Service）：将微处理器内外的访问进行统一封装，而NvRam管理层提供了一个RAM镜像来支持数据的快速读取，以统一的格式为上层的应用软件层传输而非易失性数据。抽象了地址以及属性为数据的保存、加载、校验保护、验证以及安全提供了统一的机制。
3. 系统服务（System Service）：提供实时操作系统服务，包括中断管理，资源管理，任务管理。提供功能禁止管理，通信管理，ECU状态管理，看门狗管理，同步时钟管理等服务。

ECU抽象层被分为四部分：I/O硬件抽象层，通行硬件抽象层，内层硬件抽象层，车载设备抽象层。
微控制层抽象层被分为四部分：I/O驱动、通信驱动、内存驱动、微处理驱动。

<br>

**Linux文件系统**
![在这里插入图片描述](https://img-blog.csdnimg.cn/202104202144557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)

<br>

## Linux 
Linux 下内存检测工具：asan

linux 暂停继续进程
- & ：这通常放在命令后面，让命令在后台执行。
- jobs ：查看当前有多少在后台执行的命令。
- sleep：将目前动作延迟一段时间。
- fg：将后台命令调至前台继续运行。
- bg：将后台暂停的命令继续执行。
- nohup：不挂断地继续运行命令。

通常，一个任务是一个程序的一次执行，一个任务包含一个或多个完成独立功能的子任务，这个独立的子任务就是进程或线程。

## 进程 / 线程 
进程是指一个具有独立功能的程序在某个数据集上的一次动态执行过程，它是系统进行资源分配和调度的基本单位，一次任务的允许可以并发激活多个进程，这些进程相互合作来完成该任务的一个最终目标。

进程不但包括程序的指令和数据，而且包括程序计数器的所有寄存器以及存储临时数据的进程堆栈。因此，正在执行的进程包括处理器当前的一切活动。

内核调度的对象是线程，而不是进程。Linux系统中的线程很特别，它对线程和进程并不做区分。进程的另一个名字叫任务（task）。有一种不成文的习惯，把用户空间允许的程序叫进程，把内核中允许的程序叫任务。

内核将所有进程存放在双向循环链表（进程链表/任务队列）中，其中链表头是`init_task`描述符，链表的每一项都是类型为`task_struct`的进程描述符的结构，该结构包含了一个进程相关的所有信息，定义在<include/linux/sched.h>头文件中。其中包含了`status`和`pid`等域。

Linux 通过slab分配器分配task_struct结构，这样能达到对象复用和缓存着色的目的。在2.6以前的内核中，各个进程的task_struct存放在它们内核栈的尾端。由于现在用slab分配器动态生成task_struct，所以只需在栈底或栈顶创建一个新的结构(struct thread_info),他在asm/thread_info.h中定义，需要的请具体参考。每个任务中的thread_info结构在它的内核栈中的尾端分配，结构中task域存放的是指向该任务实际task_struct指针。 [——参考文章](https://blog.csdn.net/yusiguyuan/article/details/12112377)

      在内核中，访问任务通常需要获得指向其task_struct指针。实际上，内核中大部分处理进程的代码都是通过task_struct进行的。通过current宏查找到当前正在执行的进程的进程描述符就显得尤为重要。在x86系统上，current把栈指针的后13个有效位屏蔽掉，用来计算thread_info的偏移，该操作通过current_thread_info函数完成，汇编代码如下：

```cpp
movl $-8192, %eax
andl  %esp, %eax
```
最后，`current`再从`thread_info`的task域中提取并返回`task_struct`的值：`current_thread_info()->task`
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210420233225160.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)

每个进程都拥有自己的数据段、代码段、堆栈，这就造成了进程在切换等动作是需要较复杂的上下文切换动作。为了减少处理机的空闲时间，支持多处理器及减少上下文切换的开销，进程在演化中出现了另一种概念，也就是线程。

线程可以对进程的内存空间和资源分配进行访问，并与同一进程中其他线程共享。因此线程的上下文切换开销比创建进程小得多。

由于线程共享了进程的资源和地址空间，因此任何线程对系统资源的操作都会给其他进程带来影响，因此多线程的同步是一个非常重要的问题。

### 用户态
Linux采取虚拟内存管理技术，使得每个进程都有各自不干涉的进程地址空间。该地址空间是大小为4GB的线性虚拟空间。

4GB的进程空间会被分为两部分：用户空间和内核空间。用户地址空间是从0到3GB（0XC000 0000），内核地址空间占据3GB到4GB。用户进程通常情况下只能访问用户空间的虚拟地址，不能访问内核空间的虚拟地址。

![图29-1：同时执行4个线程的进程（Linux/x86-32](https://img-blog.csdnimg.cn/20210411173507555.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)
图29-1：同时执行4个线程的进程（Linux/x86-32）

图29-1其实做了一些简化。特别是，线程栈（thread stack）的位置可能会与共享库和共享内存区域混杂在一起，这取决于创建线程、加载共享库，以及映射共享内存的具体顺序。而且，对于不同的Linux发行版，线程栈地址也会有所不同。

- 进程间的信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信（inter-process communication，简称IPC）方式，在进程间进行信息交换。
- 调用 fork()来创建进程的代价相对较高。即便利用 24.2.2 节所描述的写时复制（copy-on-write）技术，仍然需要复制诸如内存页表（page table）和文件描述符表（file descriptor table）之类的多种进程属性，这意味着fork()调用在时间上的开销依然不菲。

线程解决了上述两个问题。
- 线程之间能够方便、快速地共享信息。只需将数据复制到共享（全局或堆）变量中即可。不过，要避免出现多个线程试图同时修改同一份信息的情况，这需要使用同步技术。
- 创建线程比创建进程通常要快10倍甚至更多。（在 Linux 中，是通过系统调用 clone()来实现线程的）线程的创建之所以较快，是因为调用 fork()创建子进程时所需复制的诸多属性，在线程间本来就是共享的。特别是，既无需采用写时复制来复制内存页，也无需复制页表。

除了全局内存之外，线程还共享了一干其他属性（这些属性对于进程而言是全局性的，而并非针对某个特定线程），包括以下内容：
- 进程ID（process ID）和父进程ID
- 进程组ID与会话ID（session ID）
- 控制终端
- 进程凭证（process credential）（用户ID和组ID ）
- 打开的文件描述符
- 由fcntl()创建的记录锁（record lock）
- 信号（signal）处置
- 文件系统的相关信息：文件权限掩码（umask）、当前工作目录和根目录
- 间隔定时器（setitimer()）和POSIX定时器（timer_create()）
- 系统V（system V）信号量撤销（undo，semadj）值
- 资源限制（resource limit）
- CPU时间消耗（由times()返回）
- 资源消耗（由getrusage()返回）
- nice值（由setpriority()和nice()设置）

各线程所独有的属性，如下列出了其中一部分。
- 线程ID（thread ID）
- 信号掩码（signal mask）
- 线程特有数据
- 备选信号栈（sigaltstack()）
- errno变量
- 浮点型（floating-point）环境（见fenv(3)）
- 实时调度策略（real-time scheduling policy）和优先级
- CPU亲和力（affinity，Linux所特有）
- 能力（capability，Linux所特有）
- 栈，本地变量和函数的调用链接（linkage）信息

如图29-1 所示，所有的线程栈均驻留于同一虚拟地址空间。这也意味着，利用一个合适的指针，各线程可以在对方栈中相互共享数据。这种方法偶尔也能派上用场，但由于局部变量的状态有效与否依赖于其所驻留栈帧的生命周期，故而需要在编程中谨慎处理这一问题。（当函数返回时，该函数栈帧所占用的内存区域有可能为后续的函数调用所重新使用。如果线程终止，那么新线程有可能会对已终止线程的栈所占用的内存空间重新加以利用）。若无法正确处理这一依赖关系，由此而产生的程序bug将难以捕获。

[参考文章](https://www.zhihu.com/question/25532384/answer/1600133694)

由于在Linux系统每一个进程都会有/proc文件系统下与之对应的一个目录，因此通过/proc文件系统可以查看某个进程的地址空间的映射情况。例如运行一个应用程序，如果它的PID为13707，输入 cat /proc/13707/maps命令，可以查看该进程的内存映射情况。

<br>

对于连续（joinable）和 分离（detached）最重要的规则：
1. 不要连接一个已经被连接的线程：已连接的线程栈空间已被收回，再次连接将得到不可连接线程的消息。
2. 不要连接一个分离线程：连接操作只可用于可连接的线程。因为分离线程栈空间的收回是由系统内部来做的。

### 内核态
一直以来，**Linux内核并没有严格区分线程进程的概念**，每一个执行实体都是一个`task_struct`结构，一般称之为进程。通过系统调用clone创建子进程时，可以有选择的让子进程共享父进程所引用的资源。这样的子进程通常称为轻量级进程（lightweight process）。

**Linux上的线程就是基于轻量级进程，由用户态的pthread库实现的。** 使用pthread以后，在用户看来，每一个task_struct就对应一个线程，而一组线程及它们共同引用的一组资源就是一个进程。

[参考文章](https://bbs.huaweicloud.com/forum/thread-85092-1-1.html#)

### 同一进程用户态和内核态切换
每个进程会有两个栈，一个用户栈，存在于用户空间，一个内核栈，存在于内核空间(可通过task_struct 中的stack变量访问）。当进程在用户空间运行时，CPU堆栈指针寄存器里面的内容是用户堆栈地址；当进程在内核空间时，CPU堆栈指针寄存器里的内容是内核栈空间地址，使用内核栈。

当进程通过**系统调用**、或是发生**中断异常**陷入内核态时，进程使用的堆栈也要从用户栈转到内核栈。进程陷入内核态后，先把用户态堆栈的地址保存在内核栈之中，然后设置堆栈指针寄存器的内容为内核栈的地址，这样就完成了用户栈向内核栈的转换；

当进程从内核态恢复到用户态之行时，在内核态之行的最后将保存在内核栈里面的用户栈的地址恢复到堆栈指针寄存器即可。这样就实现了内核栈和用户栈的互转。

在进程从用户态转到内核态的时候，进程的内核栈总是空的。这是因为，当进程在用户态运行时，使用的是用户栈。当进程陷入到内核态时，内核栈保存进程在内核态运行的相关信息，但是一旦进程返回到用户态后，内核栈中保存的信息无效，会全部恢复，因此每次进程从用户态陷入内核的时候得到的内核栈都是空的。所以在进程陷入内核的时候，直接把内核栈的栈顶地址给堆栈指针寄存器就可以。
<br>

### 进程
所有进程的祖先叫做进程0idle进程，也称为init_task，因为其task_struct类型变量名字叫做init_task），在系统初始化阶段由`start_kernel()`函数从无到有手工创建的一个内核线程。0号进程一直处于“内核态”。

idle进程的工作（运行逻辑）：

- 设置执行环境；
- 执行start_kernel()完成Linux内核的初始化工作，包括初始化页表，初始化中断向量表，初始化系统时间等。执行start_kernel()完成Linux内核的初始化工作，包括初始化页表，初始化中断向量表，初始化系统时间等。
- 调用kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND)，创建init 进程；
- 调用 cpu_idle() 演变成了idle进程。

`进程1`又称为`init进程`，是所有**用户进程**的祖先。

由进程0在`start_kernel`调用`rest_init`，然后在`rest_init`中调用`kernel_thread`函数创建。`init进程`PID为1，当调度程序选择到`init进程`时，`init进程`开始执行`kernel_init ()`函数

init是个普通的用户态进程，它是Unix系统内核初始化与用户态初始化的接合点，它是所有用户进程的祖宗。在运行init以前是内核态初始化，该过程（内核初始化）的最后一个动作就是运行`/sbin/init`可执行文件。

init 进程的工作（运行逻辑）：

- 被idle父进程创建起来后，开始执行kernel_init函数，继续系统初始化工作，如挂载根文件系统，根据/etc/inittab文件初始化相关程序；
调用kernel_execve，开始执行/sbin/init程序（这里会从内核态程序切换成用户态特权等级），变为守护进程监视系统其他进程

Linux中进程状态：
- R (TASK_RUNNING)，可执行状态
- S (TASK_INTERRUPTIBLE)，可中断的睡眠状态
- D (TASK_UNINTERRUPTIBLE)，不可中断的睡眠状态
- T (TASK_STOPPED or TASK_TRACED)，暂停状态或跟踪状态
- Z (TASK_DEAD - EXIT_ZOMBIE)，退出状态，进程成为僵尸进程
- X (TASK_DEAD - EXIT_DEAD)，退出状态，进程即将被销毁

进程的创建和执行：Linux中进程的创建很特别，它分成了两个单独函数去执行，`fork函数` 和 `exec函数族`。
- 首先，`fork（）`通过拷贝当前进程创建一个子进程。使用fork（）函数得到的子进程是父进程的一个复制品，它从父进程继承了整个进程的地址空间，包括进程上下文、代码段、进程堆栈、内存星系、打开的文件描述符、进程优先级、组号、当前工作目录等。子进程与父进程的区别仅仅在与PID（每个进程唯一）、PPID（父进程的进程号，子进程将其设置为被拷贝进程的PID）和某些资源和统计量（例如，挂起的信号，它没有必要被继承）。<br>
fork返回值：0表示子进程，大于0的整数（子进程PID）代表父进程，-1表示失败。<br>
实际上是在父进程执行fork()函数时，父进程会复制出一个子进程，并且父子进程的代码从fork()函数的返回开始分别在两个地址空间中运行，从而使两个进程分别获得其所属fork()函数的返回值，其在**父进程中的返回值是子进程的进程号**，**在子进程中返回0**，因此可以通过返回值判断该进程是父进程还是子进程。
- `exec（）`负责读取可执行文件并将其载入地址空间开始运行。把这两个函数合起来使用的效果跟其他系统使用的单一函数的效果相似。<br>
exec函数族提供了一个进程中启动另一个程序执行的方法，它可以根据指定的文件名或目录名找到可执行文件，并用它替换原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其它全部被新的进程替换了。<br>
在Linux中使用exec函数族主要有两种情况：1. 当进程认为自己不能再为系统和用户作出贡献时，就可以调用exec函数族中任意一个函数让自己重生。 2. 如果一个进程想执行另一个程序，那么它就可以调用fork()函数新建一个进程，然后调用exec函数族中的任意一个函数，这样看起来就像执行应用程序而产生了一个新进程。

现在的Linux操作系统采用了copy-on-write技术（COW），即：如果父进程和子进程中任意一个尝试修改某些区域的值，那么内核会为修改区域的那部分内存制作一个副本，一般都是虚拟内存的一页。否则不进行复制操作，比如在fork的子进程中只是调用exec函数来执行另外一个可执行文件，那么事实上就没有必要复制父进程的资源，这样会造成大量的开销浪费。<br>

`wait（）`函数用于使父进程（也就是调用`wait（）`的进程）阻塞，直到一个子进程结束或者该进程收到了一个指定的信号为止。如果该父进程没有子进程，或者它的子进程已经结束，则`wait（）`函数就会立即返回。

`waitpid（）`的作用和`wait（）`一样，但它并不一定要等待第一个终止的子进程（它可以指定需要哦等待终止的子进程），它还有若干选项，如可提供一个非阻塞版本的wait（）功能，也能支持作业控制。实际上，wait()函数只是 waitpid()函数的一个特例，在Linux 内部实现 wait()函数时直接调用的就是waitpid()函数。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421211936790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)

进程的终止：linux首先把终止的进程设置为僵尸状态，这是进程无法投入运行，它的存在只为父进程提供信息，申请死亡。父进程得到消息后，开始调用`wait函数族`，最后终止了子进程，子进程占用的资源被全部释放。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421211343726.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)

<br>

**优先级反转：**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210412220616525.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210414221038576.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)
#### 守护进程
守护进程（Daemon进程），是Linux中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。守护进程常常在系统引导装入时启动，在系统关闭时终止。Linux系统有很多守护进程，大多数服务都是通过守护进程实现的，同时，守护进程还能完成许多系统任务，例如，作业规划进程crond、打印进程lqd等（这里的结尾字母d就是Daemon的意思）。

由于在Linux中， 每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相 应的进程都会自动关闭。但是守护进程却能够突破这种限制，它从被执行开始运转，直到整个系统关闭时才退出。如果想让某个进程不因为用户或终端或其他地变化 而受到影响，那么就必须把这个进程变成一个守护进程。

孤儿进程：父进程在子进程前面结束，子进程将失去父亲成为一个孤儿进程，被托孤给Init进程（PID=1），很多应用利用这点创建守护进程。<br>

**编写守护进程步骤：**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421224409844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421224602182.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421224901419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)
<br>


### 线程
**多线程是为了同步完成多项任务，不是为了提高数据处理效率，而是为了提高资源使用率达到提高系统的效率。**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210417180317989.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)

主线程和子线程的默认关系是：<font color =red>无论子线程执行完毕与否，一旦主线程执行完毕退出，所有子线程执行都会终止。</font>这时整个进程结束或僵死，部分线程保持一种终止执行但还未销毁的状态，而进程必须在其所有线程销毁后销毁，这时进程处于僵死状态。(怎么防止这种内存泄漏情况，要么在你创建的线程退出时让系统回收资源detached，要么自己主动回收joined)

线程函数执行完毕退出，或以其他非常方式终止，线程进入终止态，但是为线程分配的系统资源不一定释放，可能在系统重启之前，一直都不能释放，终止态的线程，仍旧作为一个线程实体存在于操作系统中，什么时候销毁，取决于线程属性。通常，这种终结方式并非我们期待的结果。而且一个潜在的问题是未执行也不一定释放完就终止的子线程，除了作为线程实体占用的资源外，其线程函数占用的资源（动态内存，网络端口）。

在这种情况下，主线程和子线程通常定义以下两种关系：

1. 可会合（joinable）：这种关系下，主线程需要明确执行等待操作，在子线程结束后，主线程的等待操作执行完毕，子线程和主线程会合，这时主线程继续执行等待操作之后的下一步操作。（当使用join方式时，会阻当前代码等待线程完成退出后，才会继续向下执行）主线程必须会合可会合的子线程。在主线程的线程函数内部调用子线程对象的wait函数实现，即使子线程能够在主线程之前执行完毕，进入终止态，也必须执行会合操作，否则，系统永远不会主动销毁线程，分配给该线程的系统资源也永远不会释放。

2. 相分离（detached）：表示子线程无需和主线程会合，也就是相分离的，这种情况下，子线程一旦进入终止状态，这种方式常用在线程数较多的情况下，有时让主线程逐个等待子线程结束，或者让主线程安排每个子线程结束的等待顺序，是很困难或不可能的，所以在并发子线程较多的情况下，这种方式也会经常使用。

在任何一个时间点上，线程是可结合（joinable）或者是可分离的（detached），一个可结合的线程能够被其他线程回收资源和杀死，在被其他线程回收之前，它的存储器资源如栈，是不释放的，相反，一个分离的线程是不能被其他线程回收或杀死的，它的存储器资源在它终止时由系统自动释放。

<br>

### Linux多线程编程
1. 创建线程：
- [参考文章](https://blog.csdn.net/mybelief321/category_1431937.html)
-  线程创建：创建线程实际上就是确定调用该线程函数的入口点，这里通常使用的函数是`pthread_create()`。在线程创建后，就开始运行相关的线程函数。
- 线程退出：在线程创建后，就开始运行相关的线程函数，在该函数运行完之后，该线程也就退出了，这也是线程退出的一种方法。另一种退出线程的方法是使用函数`pthread_exit()`，这是线程的主动行为。这里要注意的是，在使用线程函数时，不能随意使用`exit()`退出函数来进行出错处理。由于`exit()`的作用是使调用进程终止，而一个进程往往包含多个线程，因此，在使用`exit()`之后，该进程中的所有线程都终止了。在线程中就可以使用`pthread_exit()`来代替进程中的`exit()`。
- 线程等待：<font color =red>由于一个进程中的多个线程是共享数据段的，因此，通常在线程退出后，退出线程所占用的资源并不会随着线程的终止而得到释放。</font> 正如进程之间可以用`wait()`系统调用来同步终止并释放资源一样，线程之间也有类似机制，那就是`pthread_join()`函数。`pthread_join()`用于将当前进程挂起来等待线程的结束。这个函数是一个线程阻塞的函数，调用它的函数将一直等待到被等待的线程结束为止，当函数返回时，被等待线程的资源就被收回。
- 线程取消：前面已经提到线程调用`pthread_exit()`函数主动终止自身线程，但是在很多线程应用中，经常会遇到在别的线程中要终止另一个线程的问题，此时调用`pthread_cancel()`函数来实现这种功能，但在被取消的线程的内部需要调用`pthread_setcancel()`函数和`pthread_setcanceltype()`函数设置自己的取消状态。例如，被取消的线程接收到另一个线程的取消请求之后，是接受函数忽略这个请求；如果是接受，则再判断立刻采取终止操作还是等待某个函数的调用等。
-   线程清除：线程终止有两种情况：正常终止和非正常终止。线程主动调用`pthread_exit()`或者从线程函数中return都将使线程正常退出，这是可预见的退出方式；非正常终止是线程在其它线程的干预下，或者由于自身运行出错(比如访问非法地址)而退出，这种退出方式是不可预见的。不论是可预见的线程终止还是异常终止，都回存在资源释放的问题，如何保证线程终止时能顺利地释放掉自己所占用的资源，是一个必须考虑的问题。
从`pthread_cleanup_push()`的调用点到`pthread_cleanup_pop()`之间的程序段中的终止动作(包括调用`pthread_exit()`和异常终止，不包括`return`)都将执行`pthread_cleanup_push()`所指定的清理函数。

注：线程的执行顺序和代码顺序是无关的。

2. 线程之间的同步与互斥
- 进程间的互斥关系与同步关系存在的根源在于临界资源。临界资源是在同一时刻只允许有限个（通常只有一个）进程可以访问（读）或修改（写）的资源，通常包括硬件资源（处理器、内存、存储器及其它外围设备等）和软件资源（共享代码段、共享结构和变量等）。访问临界资源的代码叫做临界区，临界区本身也会称为临界资源。
-  由于线程共享进程的资源和地址空间，因此在对这些资源进行操作时，必须考虑到线程间资源访问的同步与互斥问题。这里主要介绍Posix中两种线程同步机制，分别为互斥锁和信号量。这两个同步机制可以通过互相调用对方来实现。
- 互斥锁又称为互斥性信号量，其管理的是资源的使用权，是一种特殊的二值型信号量，适用于同时可用的资源是唯一的情况，同时可以解决信号量存在的优先级反转问题。
- 信号量更适用于同时可用的资源为多个的情况。
-  互斥锁：在同一个时刻只能有一个线程掌握某个互斥锁，拥有上锁状态的线程能够对共享资源进行操作。若其他线程希望上锁一个已经被上锁的互斥锁，则该线程就会被挂起，直到上锁的线程释放掉互斥锁为止。可以说，这把互斥锁保证让每个线程对共享资源按顺序进行原子操作。

#### 临界区
临界资源是同一时刻只允许有限个（通常只有一个）进程可以访问（读）或修改（写）的资源。通常包括硬件资源（处理器、内存、存储器以及其他外设等）和软件资源（共享代码段、共享结构和变量等）。访问临界资源的代码叫做临界区，临界区本身也称为临界资源。
<br>

在linux系统，使用信号量来控制临界资源访问：
1. 创建信号量或获得系统中已存在的信号量（调用`semget()`函数），不同进程通过使用同一个信号量的键值来获得同一个信号量。
2. 初始化信号量。此时使用`semctl()`函数的SETVAL操作。当使用二维码信号量时，通常将信号量初始化为1。
3. 进行信号量的PV操作，此时调用`semop()`函数，这一步是实现进程间的同步和互斥的核心工作部分。
4. 如果不需要信号量，则从系统中删除它，此时使用`semctl()`函数的IPC_RMID操作。需要注意的是，在程序中不应该出现对已经删除的信号量的操作。

```c
{
	// 设R为某种资源，S为资源R的信号量
	INIT_VAL(S);	// 信号量S初始化
	非临界区；
	P(S);			//进行P操作，信号量减一
	临界区(资源R);	// 只有有限个（通常只有一个）进程被允许进入该区
	V(S);			// 进行V操作，信号量加一
	非临界区：
}
```
当我们把S的初始值设为1，当线程A第一个调用P(S)后，S值就变成了0，A成功进入临界区，在A退出临界区之前，线程B如果调用P(S)，S就会变为-1，满足S<0的判断条件，线程B就被阻塞了。等A调用V(S)后，S值又变成0，满足S<=0，就会把线程B唤醒，B就能进入临界区了。
<br>


#### 互斥锁
相关函数：
 1. 互斥锁初始化：pthread_mutex_init() 
 2. 互斥锁上锁：pthread_mutex_lock()
 3. 互斥锁判断上锁：pthread_mutex_trylock()
 4. 互斥锁解锁：pthread_mutex_unlock()
 5. 消除互斥锁：pthread_mutex_destroy()

其中，互斥锁又可以分为快速互斥锁、递归互斥锁和检错互斥锁。这3种锁的区别主要在于其它未占有互斥锁的线程在希望得到互斥锁时是否需要阻塞等待。
- 快速互斥锁是指调用线程会阻塞直至拥有互斥锁的线程解锁为止；（默认）
- 递归互斥锁能够成功地返回，并且增加调用线程在互斥上加锁的次数；
- 检错互斥锁则为快速互斥锁的非阻塞版本，它会立即返回并返回一个错误信息。默认属性为快速互斥锁；

挂起： 一般是主动的，由系统或程序发出，因此回复也应主动完成。
阻塞：一般是被动的，在抢占资源中得不到资源，被动的挂起，等待某种资源释放或信号将它唤醒，你不知道它什么时候阻塞，也不清楚什么时候恢复。

#### 条件变量
与互斥锁不同，条件变量是用来等待而不是用来上锁的。条件变量用来自动**阻塞**一个线程，直到重新唤醒。通常条件变量和互斥锁同时使用。条件变量(cond)是在多线程程序中用来实现"等待->唤醒"逻辑常用的方法。[——参考文章](https://punmy.cn/2018/06/07/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%88Condition%20Variables%EF%BC%89.html)

为什么有互斥锁，还需要条件变量？

引入条件变量的目的：在使用互斥锁的基础上引入条件变量可以使程序的效率更高，因为条件变量的引入明显减少了线程取竞争互斥锁的次数。执行`pthread_cond_wai`t或`pthread_cond_timedwait`函数的线程明显知道了条件不满足，因此在其释放锁之后就没有必要再跟其它线程去竞争锁了，只需要阻塞等待signal或broadcast函数将其唤醒。这样提高了效率。

互斥锁用于上锁，条件变量用于等待.

举个例子：

不加条件变量
```cpp
/* 
 * Assume we have global variables:
 * int iCount == 0;
 * pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
 */

//thread 1:
thread 1 () {
	while(1)
	{
	    pthread_mutex_lock(&mutex);
	    iCount++;
	    pthread_mutex_unlock(&mutex);
	}
}



//thread 2:
thread 2 () {
		while(1) {
		    pthread_mutex_lock(&mutex);
		    iCount++;
		    while (iCount >= 100) //忙等待，线程一直处于运行，耗费资源
		    {
		        printf("iCount >= 100\r\n");
		        break;
		    }
		    pthread_mutex_unlock(&mutex);
	    }
}
```
添加条件变量：
```cpp

//thread1 :
thread 1 () {
	while (1)
	{
	    pthread_mutex_lock(&mutex);
	    iCount++;
   	    pthread_mutex_unlock(&mutex);
	    while (iCount >= 100)
	    {
	        pthread_cond_signal(&cond);
	    }
	}
}

//thread2:
thread 2 () {
	while(1)
	{
	    pthread_mutex_lock(&mutex);
	    iCount++;
	    while (iCount < 100) {      //由于调用pthread_cond_wait()而被阻塞的线程在被唤醒时，
	                               //其需要等待的条件可能依然是未被满足的(这种情况被称为//spurious wakeup)，
                                  //所以需要在循环里继续做检查，如果真的发生了这种情况就继续等待。
    	    pthread_cond_wait(&cond, &mutex);  // 线程被阻塞挂起，等待信号来临，并且释放mutex
	    }  

	    pthread_mutex_unlock(&mutex);	
	    printf("iCount >= 100\r\n");
	}
}
```
在thread 2 调用 pthread_cond_wait() 的时刻到 thread 2真正进入 wait 状态时，是存在着时间差的。如果在这段时间差内 thread1 调用了 pthread_cond_signal() 那这个 signal 信号就丢失了。给 wait 加锁可以防止同时有另一个线程在 signal。


<br>

#### 信号量

信号量就是操作系统中多用到的PV原子操作，它广泛应用于进程或线程间的同步与互斥。信号量本质上是一个非负的整数计数器，包括一个称为信号量的变量和在该信号量下等待资源的进程等待队列，以及对信号量进行的两个原子操作（P/V操作）。其中，信号量对应于某一种资源，取一个非负的整形值。信号量值（常用sem_id表示）指的是当前可用的该资源的数量，若等于0则意味着目前没有可用的资源。


- P操作：如果有可用的资源（信号量值>0），则此操作所在的进程占用一个资源（此时信号量值减1,进入临界区代码）;如果没有可用的资源（信号量值=0）,则此操作所在的进程被阻塞直到系统将资源分配给该进程（进入等待队列，一直等到资源轮到该进程）。
- V操作：如果在该信号量的等待队列中有进程在等待资源，则唤醒一个阻塞进程;如果没有进程等待它，则释放一个资源（即信号量值加1）。
- 
   PV原子操作是对整数计数器信号量sem的操作。一次P操作使sem减1，而一次V操作使sem加1。进程（或线程）根据信号量的值来判断是否对公共资源具有访问权限。当信号量sem的值≥0时，该进程（或线程）具有公共资源的访问权限；相反，当信号量sem的值<0时，该进程（或线程）就将阻塞直到信号量sem的值≥0为止。


 PV原子操作主要用于进程或线程间的同步和互斥这两种典型情况。若用于互斥，几个进程（或线程）往往只设置一个信号量sem，其操作是无序的，流程如图1所示。

当信号量用于同步操作时，往往会设置多个信号量，并安排不同的初始值来实现它们之间的顺序执行，其操作耦合了顺序性，流程如图2所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210417193008493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)
Linux实现了Posix的无名信号量，主要用于线程间的互斥与同步。这里主要介绍几个常见函数：
- sem_init()用于创建一个信号量，并初始化它的值。
- sem_wait()和sem_trywait()都相当于P操作，在信号量>0时，它们能将信号量的值减1。两者的区别在于信号量<0时，sem_wait(0将会阻塞进程，而sem_trywait则会立即返回。
- sem_post()相当于V操作，它将信号量的值加1，同时发出信号来唤醒等待的进程。
- sem_getvalue()用于得到信号量的值。
- sem_destroy()用于删除信号量。

3. 经典"生产者-消费者"问题
问题描述如下：

   有一个有限缓冲区（这里用有名管道实现FIFO式缓冲区）和两个线程：生产者和消费者，它们不停地把产品放入缓冲区和从缓冲区拿走产品。**一个生产者在缓冲区满的时候必须等待，一个消费者在缓冲区空的时候也必须等待。**另外，因为缓冲区是临界资源，所以生产者和消费者之间必须互斥执行。它们之间的关系如下图1所示：

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210417193621993.png)
  这里要求使用有名管道来模拟有限缓冲区，并且使用信号量来解决“生产者---消费者”问题中的同步和互斥问题。






<br>

## OSEK OS调度机制
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210412233631566.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210412233659932.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210412233717325.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210412233730686.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210414220920801.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210414221019382.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)
<br>

#### 函数可重入性（Reetrancy）
重入一般可理解为一个函数在同时多次调用。例如：操作系统在进程调度过程中，或者单片机、处理器等的中断时候会发生重入的现象。

在多任务系统下，中断可能在任务执行的任何时间发生；如果一个函数的执行期间被中断后，到重新恢复到断点进行执行的过程中，函数所依赖的环境没有发生改变，那么这个函数就是可重入的，否则就不可重入。

在中断前后不都要保存和恢复上下文吗，怎么会出现函数所依赖的环境发生改变了呢？

众所周知，在进程中断期间，系统会保存和恢复进程的上下文，然而回复的上下文仅限于返回地址、CPU、寄存器等之类的少量上下文，而函数内部的诸如全局或静态变量、Buffer等不在保护之列，所以若这些值在重点期间发生了改变，那么当函数回到断点继续执行时，结果将无法预料.

可重入的函数必须满足三个条件：
1. 可以在执行的过程中被打断。
2.  被打断之后，在该函数一次调用执行玩之前，可以再次被调用（进入）。
3. 再次调用执行完之后，被打断的上次调用可以继续恢复，并正确执行.

可重入的函数可以在任意时刻中断，稍后再继续执行，不会丢失数据。

而满足下面条件之一的多数是不可重入函数：
1. 使用了静态数据结构;
2. 调用了malloc或free，它们使用了全局变量来指向空闲区；
3. 调用了标准I/O函数，标准I/O库的很多实现都使用了全局数据结构;
4. 进行了浮点运算，许多的处理器/编译器中，不可重入的 (浮点运算大多使用协处理器或者软件模拟来实现)。

不可重入的函数不能超过一个任务所共享，除非能保证函数的互斥。（或者使用信号量，或者在代码的关键部分禁用中断）

通常，以下几种情况会受到可重入性的制约：
1. 信号处理程序A内外都调用了同一个不可重入函数B，B在执行期间被信号打断，进入了A（A中调用了B），完事之后返回B被中断点继续执行。这时B函数的环境可能被改变，其结果就不可预料。
2. 多线程共享进程内部的资源，如果两个线程A，B调用同一个不可重入函数Fun，A线程进入Fun后，线程调度，切换到B，B也执行了Fun，那么当再次切换到线程A时，其调用F的结果也是不可预料的。（入函数时，应当在其前保存errno，并在其后恢复errno）


预防不可重入的几个原则：

1. 不要使用static变量和全局变量，只坚持用局部变量。
2. 若必须访问全局变量，利用互斥信号量来保护全局变量不被修改。
3. 获取得知哪些系统调用是可重入的，在多任务处理程序中都使用安全的系统调用。
4. 不调用其他任何不可重入的函数。
5. 谨慎使用堆栈`malloc/free`。
<br> 

##  shell 脚本
```
# !/bin/sh 指定脚本解释器
```
变量：
- 定义变量：定义时，变量名不加$，如 `your_name="zhang"` , 注意，变量名和等号中间不能有空格。
- 使用变量：使用一个定义过的变量，只要在变量名前面加美元符号即可。如` echo $yourname `或 `echo ${yourname}`，加花括号是为了帮助解释器识别变量的边界，防止与其它单词连接在一起，调用了其他变量（变量替换$行）

文件包含：
- 可以使用 `Source` 和 `.`关键字，如 `Source  ./function.sh ` 或  `. ./function.sh `
- 若 function.sh 是用户传入的参数，如何获得它的绝对路劲呢？方法是：
--   real_path = \`readlink -f $1\` ，注：\$1是用户输入的参数，如function.sh，\$n是用户输入的第N个参数。
--  `. $real_path`

`if`语句：
- ·-e· filename：若filename存在，则为真。
- `-d` filename：若filename为目录，则为真。
- `-f` filename：若filename为常规文件，则为真。
- `-L` filename：若filename符号链接，则为真。
-  `-r.w.x` filename：若filename可读写执行，则为真。
- `-s` filename：若filename长度不为0，则为真。
- `-h` filename：若filename是软连接，则为真。
- filename `-nt/-ot` filename2：若filename比filename2新/旧，则为真。

整形变量表达式：
- `-eq` ：等于
- `-ne` ：不等于
- `-gt` ：大于
- `-ge` ：大于等于
- `-it` ：小于
- `ie`：小于等于

字符变量表达式：
-  if [ $a = $b ] ：等于
-  if [ $a != $b ] ：不等于
-  if [ -n $string ] ：非空
-  if [ -z $string ] ：为空
-  if [ $string ] ：非空

比较表达式：
 - if [ 表达式1 -a 表达式] ：并列
-  if [ 表达式1 -o 表达式] ：或

特殊符号：
- 连续分号`;;`（Terminator）：专用在case的选项，担任Terminator终结者的角色
- 单引号`'`（single quote）：被单引号括住的内容，被视为单一字符。在引号内的代表变数的`$`符号，没有作用，也就是说，它被视为一般符号处理，防止任何变量替换。
- 双引号`"`（double quote）：被双引号括住的内容，被视为单一字符。它防止通配符扩展，但允许变量扩展，这点和单引号的处理方式不同。
- 倒装号 \`command\`（ backticks）： 在前面的单双引号，括住的是字串，但如果该字串是一列命令列，会怎样？答案是不会执行。要处理这种情况，我们得用倒单引号来做。 
- 倒斜线`\\ ` ：在交互模式下的escape 字元，有几个作用；放在指令前，有取消 aliases的作用；放在特殊符号前，则该特殊符号的作用消失；放在指令的最末端，表示指令连接下一行。 
- 问号`? ` (wild card) ：在文件名扩展(Filename expansion)上扮演的角色是匹配一个任意的字元，但不包含 null 字元
- `&`： 后台工作 
- `$*` ：代表所有引用变量的符号。`@ `与 `$* `具有相同作用的符号，不过她们两者有一个不同点。 符号 `$* `将所有的引用变量视为一个整体。但符号` $@ `则仍旧保留每个引用变量的区段观念
- `$# `：这也是与引用变量相关的符号，她的作用是告诉你，引用变量的总数量是多少。
- `$?` 状态值 (status variable) ：一般来说，UNIX(linux) 系统的进程以执行系统调用exit()来结束的。这个回传值就是status值。回传给父进程，用来检查子进程的执行状态。

文本处理三剑客（都可以配合正则表达式使用）：
- grep：查找
- sed：编辑，利用脚本的指令来处理，编辑文本文件。
- awk：文本分析，以空格为默认分隔符，将每行切片，切开部分再进行分析处理。

`make -j8` : 开启多线程的编译，同时允许8个任务。

命令替换：$() 和 ``(反引号) 都可以用作命令替换。例： version = $(uname -r) 或 version = \`uname -r\`

正则表达式匹配的三种模式：贪婪模式Greedy、懒惰模式Reluctant、独占模式Possessive

<br><br>

# 通信
## 同步（串行） / 异步（并行）
同步和异步关注的是消息通信机制，并发和并行其实是异步线程实现的两种方式。并行其实是真正的异步，并发是个伪异步。
- 并发的关键是你有处理多个任务的能力，不一定要同时。
- 并行的关键是你有同时处理多个任务的能力。

**同步通信**：发送发发出数据后，等待接收方发回响应以后，才发下一个数据包的通讯方式。同步通信要求接受端时钟频率与发送端时钟频率一致，发送端发送连续的比特流。

同步通信是阻塞模式，代表有SPI，IIC协议，特点是通信效率高，但较为复杂。

**异步通信**：发送方发出数据后，不等待接收方发回响应，接着发送下个数据包的通讯方式。异步不需要时钟同步，发送端发完一个字节后，可经任意长的时间间隔再发下一个字节。

异步通信是非阻塞模式，代表有UART协议（需要开始位和结束位），传输效率低。

linux下经典五位哲学家吃面模型分析：(参考文章)[https://www.daimajiaoliu.com/daima/485b5ebc0100414]
<pr>

## 进程间通信
进程间通信之共享内存shm 和 Socket 通信 payload (有效负载大小)。

**Socket** ：我们知道两个进程如果需要进行通讯最基本的一个前提能能够唯一的标示一个进程，在本地进程通讯中我们可以使用PID来唯一标示一个进程，但PID只在本地唯一，网络中的两个进程PID冲突几率很大，这时候我们需要另辟它径了，我们知道IP层的ip地址可以唯一标示主机，而TCP层协议和端口号可以唯一标示主机的一个进程，这样我们可以利用ip地址＋协议＋端口号唯一标示网络中的一个进程。

socket（套接字）是应用层和传输层的一个抽象层，它把TCP/IP层的复杂关系的操作抽象为几个简单的接口供应用层调用已实现进程在网络中的通信。

Packet（包）: 在包交换网络里，单个消息被划分为多个数据块，这些数据块称为包，它包含发送者和接收者的地址信息，这些包沿着不同路径在一个或多个网络中传输，并且在目的地重新组合。

socket 进行TCP通信丢包：
- 拆包，加包头，发送，组合包。
- 如果客户端，服务端掉线，常采用心跳测试。
- 粘包，拆包问题。

TCP协议下Socket有可能丢包吗？（分包/片）
- 按顺序到达
- 乱序到达
- 有包丢失 -> 丢失包重发（如果1,2,3包发送，2包丢失，1包先交付，2包重发，到达后，2,3包一同交付）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210411121006681.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)
strean（流）：流是字节流（Byte stream）的简称，也就是长长的一串字节。其特征是连续，可以没有头没有尾，没有绝对的位置，但是由于流是连续的，所以有相对位置。

流媒体：整包分开分段发包，使数据包得以像流水一样发送，读一点数据就处理一点数据，而不用在使用前下载整个包文件。

使用流的核心是底层有个缓冲区BUFFER，这样不至于因为写的太快不及读取或相反的情况发生，从而协调了读写的不同速度的问题。

TCP协议 保证了数据通信的完整性和可靠性，IP协议解决了多个局域网互通，Ethernet以太网协议解决了局域网点对点通信。

慢启动（slow start）和 ACK（acknowledgement，携带了两个信息）：期待要收到下一个数据包的编号和接收方的接收窗口的剩余容量。通过检查ACK编号信息，可以实现丢包重发。

**资源竞争**：多线程程序可以并行运行，可是IDE输出结果有时不如预期，原因在于控制台只有一个，只有一个线程拥有这一个唯一的控制台将数字输出。由于控制台是系统资源，这里控制台拥有的管理是操作系统完成的。但是，假如是多个线程共享空间的数据，这就需要自己写代码去控制，每个线程何时能够拥有共享数据进行操作。共享数据的管理以及线程间通信时多线程两核心。

多线程程序是并发执行，对多线程的公用资源不能保证能被正确利用，即不保证能被独占。并发执行的时候，哪个线程得到运行的机会是随机的，也是不可预测的。为了解决多线程中某个程序对资源的独占，只允许一个线程拥有共享资源的独占。

### 同步与互斥
- 互斥：互斥就是指某一资源同时只能允许一个访问者对其进行访问，其他访问者必须等待。具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。（间接约束关系，争夺资源）<br>
对于线程来说，互斥就是说两个线程之间不可以同时允许，它们之间会相互排斥，必须等一个线程运行完毕之后，另一个才能运行。
- 同步：同步又称直接约束关系，是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的**有序访问**。（相互协作）

进程拥有独立资源，进程之间交换数据需要考虑通信。线程之间共享资源，需要考虑资源的同步与互斥。

多进程之间的**通信方式**（Inter-Process communication，IPC）:
- 文件映射：本地之间
- 共享内存：本地之间
- 匿名管道：本地之间
- 命名管道：跨服务器
- 邮件槽：一对多的传输数据
- 剪切板：本地之间
- Socket：跨服务器

多线程之间的通信方式：
- 全局变量
- 自定义消息响应

消息同步互斥机制：
- 临界区，互斥量
- 原子操作
- 自旋锁，互斥锁，读写锁等
- 事件，信号量，PV原子操作

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210411165105402.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)
 **自旋锁**：自旋锁加锁失败后，线程会忙等待，直到它拿到锁。线程一直是running(加锁->解锁)，死循环检测锁的标志位。缺点是一直占用CPU，并且有可能造成死锁。（若资源被占用，申请着就一直循环在那查看该自旋锁占用者是否已经释放了锁）

- 用于临界区互斥
- 在任何时刻最多只有一个执行单元获得锁
- 要求持有锁的处理器锁占用的时间尽可能短（否则其他线程会一直阻塞）
-等待锁的进程进入忙等待

所以，如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。

自旋锁死锁：嵌套拥有自旋锁。

a进入自旋锁，b等待a释放并开始自选忙等待

```
int a() {
    spinLock();
    b();
    unLock();
}
int b() {
    spinLock();
    unLock();
}
```
<br>

**互斥锁**：互斥锁加锁失败后，线程会释放 CPU ，给其他线程。线程会从sleep(加锁)->running(解锁)，过程有上下文的切换，CPU的抢占，信号的发送等开销（若资源已被占用，资源申请者只能进入睡眠状态）。

对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的。所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本（两次上下文的切换）。

[参考文章](https://www.cnblogs.com/xiaolincoding/p/13675202.html)

互斥锁死锁：假设A线程持有锁a，B线程持有锁b，而线程访问临界的条件是同时具有锁a和锁b，那么A就会等待B释放锁b，B也会等待A释放锁a。

互斥锁死锁产生的情况：1.系统资源不足。如果系统资源足够，每个申请锁的线程都能后获得锁，那么锁情况就会大大降低。 2.申请锁顺序不当。当两个线程按照不同的顺序申请，释放锁资源时也会产生死锁。

互斥锁死锁产生的条件：1.互斥属性：即每次只能有一个线程占用资源。2.请求与保持：即已经申请到锁资源的线程可以继续申请。在这种情况下，一个线程也可以产生死锁情况，即抱着锁找锁。3.不可剥夺：线程已经得到锁资源，在自己没有主动释放之前，不能被强制剥夺，只能由自己释放。 4.循环等待：多个线程形成环路等待，每个线程都在等待相邻线程的所资源。

[参考文章](https://blog.csdn.net/qq_33951180/article/details/72801228)

自旋锁和互斥锁使用的不同场景：
1. 若是多核处理器，如果预计线程等待所时间很短，短到比线程两次上下文切换的时间要少的情况下，使用自旋锁是划算的，反之，使用互斥锁。
2. 若是单核处理器，一般建议不要使用自旋锁。因为在同一时间只有一个线程处于运行状态，那如果此时该运行线程（非执锁线程，优先级高）发现无法获得锁，只能等待锁，但因为自身不挂起，所以那个获取到锁的线程没有办法进入到运行状态，只能等到运行线程把操作系统分配给它的时间片用完，才有机会被调度，这种情况下使用自旋锁的代价很高。
3. 若代码经常被调用，但竞争情况很少发生，应该考虑自旋锁，自旋锁开销小。

 
**临界区**
- 通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。
- 它并不是核心对象，不是属于操作系统维护的，而是属于进程维护的。
- 临界区最大的特色是其同步速度很快，但是其只能用来同步本进程内的线程，而不可用来同步多个进程中的线程。

**互斥量**
- 采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程同时访问。当前拥有互斥对象的线程处理完任务后必须将线程交出，以便其他线程访问该资源。
- 互斥量可以在整个系统中被任意进程的任意线程访问到，但它严格限定只有获取了互斥量的线程才能释放该互斥量。

临界区和互斥量都有"线程所有权"概念，所以它们是不能用来实现线程间的同步的，只能用来实现互斥。

原因是由于创建临界区或互斥量的线程不用等待`leaveCriticalSectional()`,`setevent`就可以无条件进入保护的程序段，因为它拥有这个权力。另外，互斥器可以很好的处理”遗弃“操作。若线程在未释放对向象的时候就意外终止的，其它线程可以等待到一个`WAIT_ABANDONED_0`。但是事件和信号量都不能做到。
<br>

**信号量**
- 信号量也是内核对象。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。
- 与临界区和互斥量不同，可以实现多个线程同时访问公共区域数据，原理与操作系统中PV操作类似，先设置一个访问公共区域的线程最大连接数，每有一个线程访问共享区资源数就减一，直到小于等于零。
- 注意区分信号和信号量。信号是进程间通信机制中唯一的异步**通信**机制。

**事件**
- 通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作。
- 通过线程间出发事件实现同步互斥。

事件和信号量都可以实现线程和进程间的互斥和同步。就使用效率来说，临界区的效率是最高的，因为它不是内核对象，而其它的三个都是内核对象，调用要进入内核态，效率相对来说就比较低。但如果要跨进程使用还是要用到互斥器、事件对象和信号量。

<br>

### 管道
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421225227841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421225555479.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421225637219.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421225933712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)

### 共享内存
共享内存是一种最为高效的进程间通信方式，因为进程可以直接访问内存，不需要进行任何数据的复制。为了在多个进程间交换信息，内核专门留出了一块内存区，这段内存区可以由需要访问的进程将其映射到自己的私有地址空间。因此，进程就可以直接读写这一段内存而不需要进行数据的复制，从而提高效率。
1. 创建共享内存。也就是从内存中获得一段共享内存区域，在Linux使用的函数是`shmget()`。
2. 映射共享内存。也就是把这段创建的共享内存映射到具体的进程空间中，在Linux使用的函数是`shmatI()`。
3. 撤销映射。 使用完共享内存就需要撤销，在Linux使用的函数是`shmdt()`。

因为共享内存自身并不提供同步机制，所以应额外实现不同进程间的同步。

<br>

## I/O 模型
五种 I / O 模型 ： 
- 阻塞I/O型（Blocking I/O）
- 非阻塞I/O型（nonblocking I/O）
- I/O多路转接模型（I/O multiplexing ）：select and poll
- 信号驱动I/O模型（signal driven I/O）： SIGIO
- 异步I/O模型（asynchronous  I/O） ： the Posix aio_function

<br>

# 编程设计
编程：
- 系统编程（system programming）: 编写库
- 应用编程（application programming）：利用库编写某种功能的应用

四组不同而相辅相成的编程泛型（programming paradigms）：
- 过程式编程（procedural-based）
- 基于对象编程（object-based）
- 面向对象编程（object-oriented）
- 泛型编程（generics）

契约式设计（Design by contract）: 一种设计计算机软件的方法，方法要求软件者为软件组件定义正式的，精准的并可验证的接口。这样为传统的抽象结构类型由增加了先决条件，后验条件和不变式。这种方法的名字里用的“契约”只是一种比喻，因为它和商业契约的情况有点类似。

契约作用域两方，每一方都会完成一些任务，从而促进契约的达成。但同时，每一方也会接受一些义务，作为契约的前提，在任意一方无视了必尽的义务，则契约失败。契约式编程可以严格区分责任，让每个人都不必为了迁就他人错误而进行【艰难的编码】，每个人按契约处理好自己的事情，让损毁契约的人承担责任。

防御式编程：人类都是不安全的，不值得信赖的，所有人都会犯错误，而你写的代码，应该考虑到所有可能发生的情况，让你的程序不会因为他人的错误而发生错误。

程序需对可能的错误输入作出兼容，其手段可以有如下两种：
1. 作出兼容，运行本次兼容（例如26种设计模式种的NULL对象模式）
2. 错误提示，种植本次执行，提示重新再来。

## 编程语言
**inline关键字**：解决一些频繁调用的小函数消耗栈空间的问题。
- 内联函数有些类似于宏。内联函数的代码会被直接嵌入在它被调用的地方，调用几次就嵌入几次，没有使用call指令。这样省去了函数调用时的一些额外开销，比如保存和恢复函数返回地址等，可以加快速度。（作为接口，宏不够清晰）
- 限制：inline只适合函数体内代码简单的函数使用，不能包含复杂的结构控制语句，如 while、switch，并且不能内联函数本身不能是直接递归函数。
- inline 函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思（也说明了inline不应该出现在函数声明中）。
- 建议：建议 inline 函数的定义放在头文件中，因为内联函数要在调用点展开，所以编译器必须随处可见内联函数的定义，要不然就成了非内联函数的调用了。所以，这要求每个调用了内联函数的文件都出现了该内联函数的定义。<br>
因此，将内联函数的定义放在头文件里实现是合适的，省却你为每个文件实现一次的麻烦。
- 注意点：1. 关键字 inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前面不起任何作用。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。
- 2.慎用inline：内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。 如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
- 3.以下情况不宜使用内联： （1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 （2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构函数可能会隐藏一些行为，如"偷偷地"执行了基类或成员对象的构造函数和析构函数。所以不要随便地将构造函数和析构函数的定义体放在类声明中。一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了 inline 不应该出现在函数的声明中）。
- static inline的内联函数，一般情况下不会产生函数本身的代码，而是全部被嵌入在被调用的地方。如果不加static，则表示该函数有可能会被其他编译单元所调用，所以一定会产生函数本身的代码。所以加了static，一般可令可执行文件变小。内核里一般见不到只用inline的情况，而都是使用static inline。

**类内数组如何初始化**：[跳转](https://blog.csdn.net/weixin_40539125/article/details/85618135)

数组名不能作为左值 ！！！ 编译器会认为数组名作为左值代表的是a的首元素的首地址，但是这个地址开始的一块内存是一个整体，我们只能访问数组的某个元素，而无法把数组数组当做一个整体来进行访问。 所以，我们可以把a[i]当左值，无法把a当左值。

sizeof(string) = 4：字符串所占的空间是从堆中动态分配的，与sizeof()无关，其大小的值可能因编译器不同而不同。

宏（Macro）属于编译器预处理的范畴，属于编译期概念（而非运行期概念）
- #define定义时，斜杠`\`是用来续行的，分段可以防止一行代码太长影响阅读，`#`用来把参数转换为字符串，相当给参数加上双引号，`##` 用来连接前后的两个参数，把它们变成一个字符串，`#@`给参数加上单引号。
- `__FILE__` 在预编译时会替换成当前的源文件名，`__LINE__` 在预编译时会替换成当前的行号，`__FUNCTION__` 在预编译时会替换成当前的函数名称，`__TIME__ `在源文件中插入当前编译时间，`__DATE__ `在源文件中插入当前的编译日期.

**问：为什么应该使用模块（Module）替代头文件（Header）？**
 
模块是什么？
- 库的接口（API）
 - 库的实现

使用“import”导入已命名的模块，import会在源文件中忽略预处理状态，并且选择性导入，所以弹性（resilience）非常好。

使用“import”会导入什么？

- 函数、变量、类型、模板、宏，等等；
- 公开API——其它的都隐藏；
- 没有特别的命名空间机制。

耦合性（coupling）: 耦合性越强，则独立性越差，划分模块的一个准则就是高内聚（块内联系）低耦合（块与块之间）。

XML（Extensible Markup Language）：被设计用来传输和存储数据，焦点在于数据的内容（存储配置信息）
HTML：被设计用来显示数据，焦点在于数据的外观

**类中静态成员 / 函数**：
- 静态成员不属于对象，而是属于类，不创建对象也能调用
- 静态成员函数不能访问普通成员变量（函数），需要通过对象间接访问成员变量（函数）。只能直接访问静态成员变量（函数）
- 静态成员函数没有隐藏的this指针

**size_t 类型**：int小于等于数据线宽度，size_t大于等于地址线宽度。size_t存在的最大原因可能是因为：地址线宽度历史中经常都是大于数据线宽度的。使用`size_t`可能会提高代码的可移植性、有效性或者可读性，或许同时提高这三者。

size_t是标准C库中定义的无符号类型，在64位系统中为long long unsigned int，非64位系统中为long unsigned int。通常我们用`sizeof(XXX)`操作，这个操作所得到的结果就是size_t类型。size_t还经常出现在C++标准库中，此外，C++库中经常会使用一个相似的类型size_type，用的可能比size_t还要多。

结构体可以用块直接赋值（[代码测试](https://github.com/yumdeer/daily_practice/blob/master/vs_project/HW_notebook/HW_notebook/HW_notebook.cpp)）

元组tuple 是C++的一种容器，可以容纳不同类型，可以直接使用，在某些情况比结构体更加方便，简洁，直观。

std::pair是一个类模板，它可以将两个数据合成一个数据，如STL中的Map就是将`Key`和`Value`放在一起保存。

```
 std::pair <std::string,double> product1;                     // default constructor
 std::pair <std::string,double> product2 ("tomatoes",2.30);   // value init
 product2.first = "shoes";                  // the type of first is string
 product2.second = 39.90;                   // the type of second is double
```

**元编程**（Meraprogramming）是指某类计算机程序的编写。这些计算机编写或者操作其他程序（或者自身）作为它们的数据。或者在运行完成部分本应在编译时完成的工作。很多情况下与手工编写全部代码相比工作效率更高。

C++ 使用模板进行元编程: [跳转](https://www.cnblogs.com/liangliangh/p/4219879.html)

特化/偏特化：

```
template<>
class compare<char *>   //特化char*，当传入参数为char* 调用特化版本，而非通用模板
{
}

template<class Allocator>
class compare<bool, Allocator>   //一个参数被绑定到bool类型，而另一个参数任未绑定而需要用户指定
{
}
```

注意区分深拷贝与浅拷贝，以及浅拷贝造成的内存泄漏。

**常量不能被引用符引用：试图将一个const类型转换为非const类型是非法的，因为const变量存储在常量区。**

虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表即可。同一类的所有对象都使用同一虚表。

```cpp
B b;	// B是A的子类
A *p = &b;
```

虽然P是基类指针，是只能指向基类的部分，但是虚表指针亦属于基类部分，所以p可以访问对象b的虚表指针。b的虚表指针指向类B的虚表，所以p可以访问B的vtbl。

**位域**：有些信息在存储时，并不需要一个完整的字节，而只需占几个或一个二进制位，例如在存放一个开关量时，只需要0和1两种状态，用一位二进制位即可。为了节省存储空间，并使处理简便，C语言又提供了一种数据结构，称为"位域"或"位段"。

所谓"位域"是一个字节中的二进制划分为几个不同的区域，并说明每个区域的位数。每个域都有一个域名，允许在程序中按位域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。

```cpp
struct 位域结构名 {
	位域列表;
}
```
一个位域必须存储在同一个字节中，不能跨两个字节。若一个字节所剩空间不足存放另一个位域，应从另一个单位存放。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210425215209704.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)

**热补丁：**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210425215807959.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210425215818687.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)


<br>

## 编程规范
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210425215320841.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021042521553823.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210425215544848.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUzOTEyNQ==,size_16,color_FFFFFF,t_70)
<br>


## 面试题
1. 在8086汇编中，逻辑地址和物理地址是怎么转换的？
答：通用寄存器给出的地址，是段内编译地址，相应的段寄存器地址*10H + 通用寄存器内地址就得到真正想要访问的地址。（其实就是实模式）
2. 代码中特殊注释技术——TODO,FIXME和XXX
- TODO：英语翻译为待办事项，备忘录。如果代码中该标识，说明在标识处有功能待编写，待实现的功能在说明出会简要说明。 
-  FIXME：可以拆成短语，fix me ，如果代码中有该标识，说明标识处代码需要修改，甚至代码是错误的，不能工作，需要修复，如何修复会在说明中简略说明。 
- xxx：如果代码中有该标识，说明标识处代码虽然实现了功能，但是实现的方法有待商榷，希望未来能够改进，要改进的地方在说明中简要说明。
3.  hash_set 和 Set 的区别
- hash_set以hashtable为底层机制，而Set以RB-tree为底层机制。
- Set有元素自动排序功能，而hash_set没有。
- Set可在LogN下完成查找、插入和删除等操作，而Hash_set可在常数时间复杂度下完成这些操作，但取决于哈希表的负载情况。
- hash_multiset则允许键值重复
4. 类的静态成员函数不能使用类的非静态成员，因为此时静态成员函数以及分配了存储空间，而非静态成员却还没有分配内存，相当于变量声明了但是未定义就直接使用。
5. C程序的内存分配方式
答：由上到下（地址由高到低）：栈、动态连接库、堆、BBS（未初始化的全局变量）、数据段（存放初始值的全局变量）、文本段（存放代码）
6. 构造函数中“初始化列表” 和 “赋值” 的区别
- 效率：针对类类型，效率差距较大。如果在构造函数中赋值是（普通构造 + 赋值运算符/拷贝构造函数），如果是初始化列表中则是直接初始化（只调用一次拷贝构造函数，还可能通过移动语义/右值引用效率更高）。
- 特性：没有默认构造函数的类、类中存在const成员、引用类型的成员只能使用初始化列表。（const对象或引用只能初始化但是不能赋值。构造函数的函数体内只能做赋值而不是初始化）
- 特性：类的静态成员变量不能用参数初始化表初始化。
7. 什么时候需要手动设置字节对齐
答：1. 设计不同CPU下的通信协议（设计了一个结构体，32位和64位都使用）。2. 编写硬件驱动程序时寄存器的结构。
8. 僵尸进程是什么
答： 当子进程退出时，父进程没有调用wait函数或者waitpid函数等待子进程结束，又没有显示忽略SIGCHLD信号，那么它将一直保持在僵死状态。如果这是父进程结束了，init进程就会自动回收这个子进程，为它收尸。但如果父进程是一个循环，不会结束，那么这个子进程就会一直保持僵死状态。

任何一个进程（init除外）在exit()之后并非马上消失，而是留下一个成为Zombie的数据结构，等待父进程处理，这是每个子进程结束时都要经历的过程。若子进程exit后，父进程没有及时处理，使用PS命令可以看到子进程的状态是'Z'。

补救方法：杀死僵尸进程的父进程，让Init进程回收清理（此时僵尸进程变成孤儿进程）

9. mutable 关键字：加在类型前面，表示即使是常量也可以修改。
10. 全局对象的构造函数会在main函数之前执行。
11. 脏数据：数据被删除，但另一用户没有刷新，使用了该数据。
12. Unix中C程序的存储空间布局
答：参考：[代码段，数据段，堆栈段是cpu级别的概念，五大分区属于语言级别的概念，两者是不同的概念](https://zhuanlan.zhihu.com/p/337877555)
13. 程序执行之后才会产生堆和栈，内核执行程序都会调用exec函数。
14. 同步IO 和 异步IO
- 同步IO：
CPU执行的速度远远高于磁盘读写的速度或网络传输速度，当代码执行遇到磁盘读写的时候，当前线程就会一直等待，直到磁盘读写完成后返回在继续执行下面的代码，这样就造成了CPU资源的严重浪费。
为了解决这这种情况，我们可以使用多线程和多进程。
但是多进程开多了很占用系统资源，而多线程也不是能一直增加的，因为CPU要在线程之间切来切去，也很耗费时间和资源。这种情况下，我们可以使用异步IO。
- 异步IO
当执行某段耗时的代码时，只发出指令，并不等待执行结果，然后就去执行其他代码，一段时间后，当结果返回时，在通知CPU进程处理。
根据上面描述，同步是阻塞的，异步是非阻塞的。异步IO需要一个消息循环，在消息循环中，主线程不断地重复读取消息，处理消息这一过程。
也就是说，在发出IO请求到IO返回结果这一段时间里，同步IO模式下，主线程只能挂起等待，异步IO模式下，主线程会继续去处理下一个消息，这样既没有占用过多的资源，也无需在线程之间进行切换，都会大大提升多任务处理程序的性能。

15. 求`*(ptr-1)` 的值

```cpp
int a[5] = {1, 2, 3, 4, 5};
int *ptr = (int *)(&a+1); 
```
`&a`是对象（整个数组）首地址，`&a+1`是下个对象的地址，所以`*(ptr-1)`是`a[4]=5`。
`a`与`&a`的地址是一样的，但意义不同。 `*(a+1)=a[1]=2`，`*(&a+1)=a[5]`。


<br>

## 设计模式
观察者模式（订阅模式）：被观察对象状态改变，所有观察它的对象得到通知。被观察者不依赖观察者，通过依赖注入达到控制反转。
事件
通知：事件发生后，通知所有这个事件的对象。与观察者模式相比，可理解成所有对象都只以来事件系统。一半对象观察事件系统，等待特定通知；一般对象状态变化就通过事件系统发出事件。

观察者也不依赖被观察对象，他只关心事件，不需要到被观察对象那儿注册自己。
被观察者也只是普通对象，状态改变，通过事件系统发出事件就行了。

消息队列：将消息排成队列，逐步分发通知。
与事件通知对比，可理解成事件不是立即通知，而是保存到队列里，稍后通知。这个可以达到时间解耦的效果。Windows的消息循环就是一个应用。多线程情况下，消息队列优先于事件系统。

**1. 观察者模式**
以上课铃声为例子。上课铃声响，同学们回教室。

1. 简单写法

```cpp
class 上课铃{
    function 响()
        for 学生 in 学生们 do
            学生->回教室()
        end
    end
}
```

这样写有问题：

- 上课铃主动通知学生回教室（而不是学生主动观察上课铃状态改变），依赖关系反了。
-  上课铃响，老师要来上课，这个也得上课铃通知，上课铃管的东西太多了。


2. 轮询

```cpp
class 学生{
    function update()
        if 上课玲响 then
            回教室()
        end
    end
}
```

这样上课铃只管按时响就行了，也有问题：

- 学生的update会越来越复杂，学生还有很多其他事情要做呢。
- update太耗时了，学生们，要精神紧张地仔细停玲声有没有响起。

3.  使用观察者模式
```cpp
class 上课铃: Subject{
    function 响()
        NotifyObservers()
    end
}

class 学生: Observer{
    function init()
        上课玲->AddObserver(this.回教室)
    end
    function 回教室() ... end
    function un_init()
        上课玲->RemoveObserver(this.回教室)
    end
}
```


这样，上课铃只要响的时候发个通知，学生们就等通知好了。老师也类似，等通知就行了。

**小结:**
- 实际就是注册个回调函数，完美的将观察对象和被观察对象分离。(定义对象间一种一对多的依赖关系，每一个对象改变状态，则所有依赖它的对象都会得到通知，并自动更新)
- 个人理解：依赖注入，控制反转。观察者依赖被观察者，而不是被观察者依赖观察者。
<br>

**2. 事件系统**

观察者模式有两个问题：
- 观察者（学生）要获得被观察对象（铃声），然后才能注册。
有时只是要知道某个事件发生了而已，类似网络初始化好了的事件，并不需要获得网络管理对象。
- 观察者和被观察者要继承对象的，在单继承体系里，这是很昂贵的一件事。

上课铃的例子里，学生只关心铃声，不关心上课铃这个物体。用事件模式就可以换个写法

```cpp
class 事件系统{
    function register(事件类型, handle);
    function remove(事件类型, handle);
    function trigger(事件类型, 数据);
}

class 上课铃{
    function 响()
        事件系统->trigger("上课铃声")
    end
}

class 学生{
    function init()
        事件系统->register("上课铃声", this->回教室)
    end
    function 回教室() ... end
    function un_init()
       事件系统->remove("上课铃声", this.回教室)
    end
}
```

**小结：**
- 事件通知系统用的很广泛的。很多代码会有个EventDispatcher、EventControl之类的类。
特别是UI程序，当数据发生变化时通知相关UI更新。
观察者模式可以做到，但是事件通知来实现会更加简单。

**3. 消息队列**

消息队列和事件系统很像。但是消息队列不是立即通知，而是把消息先放到队列里再通知。

上课铃的例子：
```cpp
class 消息队列{
    function register(消息类型, handle);
    function remove(消息类型, handle);
    function sendMsg(消息);
    function process();
}

class 上课铃{
    function 响()
        消息队列->sendMsg("上课铃声")
    end
}

class 学生{
    function init()
        消息队列->register("上课铃声", this->回教室)
    end
    function 回教室() ... end
    function un_init()
        消息队列->remove("上课铃声", this.回教室)
    end
}

main{
    while(有消息) do
        消息队列->process()
    end
}
```

从伪代码也可以看出，消息队列和事件系统的使用基本是一样的。如果消息队列不延后处理，就是事件系统了。
消息队列可以用于多线程，接受处理消息的handle们在主线程里。发送消息的可以在其他线程里。

**简单总结**
- 需要分层解耦就用事件通知系统。
- 需要时间解耦就用消息队列。

<br>

### 上下文/语境（context）
上下文：“当前场景”、变量、对象都有作用域，上下文不仅指作用域，就算再相同作用域下也会因为当前程度的其他变量不同而不同的表现。

为什么那么多框架都设计有上下文？（把所有环境上的东西都挂在到context，有点类似与全局变量的作用？）
- context：将需要来回传递的数据聚合在一起，形成一个模块交互的上下文，各个模块像传递包裹一样，取用、修改、传递。
- 框架一般都需要支持线程/协程/进程/中断等存在切换执行过程的操作，这就需要在切换前用 context 来记录当前程序执行的相关状态，待重新切换回来后，需要用之前保存的context来从中断处继续执行。
- context并非一定是环境变量或全局变量，将其当作执行流程绑定的局部数据更加何时一点。
- context比起全局变量的一个巨大优势，就是它可以由很多套同时存在组成SandBox（沙盒）。context是optional（可选的），在运行的时候它可以是存在或不存在的。

为什么有上下文这种概念？    [——参考文献](https://www.sohu.com/a/201480740_777180)
- 内核空间和用户空间是现代操作系统的两种工作模式，内核模块运行在内核空间，而用户态应用程序运行在用户空间，它们代表不同的级别，而对系统资源具有不同的访问权限。内核模块运行在最高的级别（内核态），这个级别所有的操作都受系统信任。
- 而应用程序运行在较低级别（用户态），在这个级别，处理器控制在对硬件的直接访问以及对内存的非授权访问。内核态和用户态都有自己的内存映射，即自己的地址空间。

处理器总是处于以下状态的一种：
- 内核态：1.运行于进程上下文，内核代表进程运行与内核空间。 2.运行于中断上下文：内核代表硬件运行于内核空间。
- 用户态：运行于用户空间。
- 
系统的两种不同运行状态，才有了上下文的概念。用户空间的应用程序，如果想请求系统服务，比如操作某个物理设备，映射设备的地址到用户空间，必须通过系统调用来实现。（系统调用是操作系统提供给用户空间的接口函数）。

通过系统调用，用户空间的应用程序就会进入内核空间，由内核代表该进程运行于内核空间，这就涉及到上下文的切换，用户空间和内核空间具有不同的 地址映射，通用或专用的寄存器组，而用户空间的进程要传递很多变量、参数给内核，内核也要保存用户进程的一些寄存器、变量等，以便系统调用结束后回到用户空间继续执行。

进程上下文：
- 概念：一个进程在执行的时候，CPU的所有寄存器中的值、进程的状态以及堆栈上的内容，当内核需要切换到另一个进程时，它 需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行。
- 一个进程的上下文可以分为三个部分：
 1. 用户级上下文: 正文、数据、用户堆栈以及共享存储区；
 2. 寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；
 3. 系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。
- 进程上下文主要是异常处理程序和内核线程。内核之所以进入进程上下文是因为进程自身的一些工作需要在内核中做。例如，系统调用是为当前进程服务的，异常通常是处理进程导致的错误状态等。所以在进程上下文中引用current是有意义的。当发生进程调度时，进行进程切换就是上下文切换(context switch)。

操作系统必须对上面提到的全部信息进行切换，新调度的进程才能运行。而系统调用进行的是**模式切换(mode switch)**。模式切换与进程切换比较起来，容易很多，而且节省时间，因为**模式切换最主要的任务只是切换进程寄存器上下文的切换。**

中断上下文：
- 概念：“中断上下文” 可以理解为硬件传递过来的这些参数和内核需要保存的一些环境，主要是被中断的进程的环境。
- 条件：硬件通过触发信号，向CPU发送中断信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核， 内核通过这些参数进行中断处理。
- 内核进入中断上下文是因为中断信号而导致的中断处理或软中断。而中断信号的发生是随机的，中断处理程序及软中断并不能事先预测发生中断时当前运行的是哪个进程，所以在中断上下文中引用current是可以的，但没有意义。

事实上，对于A进程希望等待的中断信号，可能在B进程执行期间发生。例如，A进程启动写磁盘操作，A进程睡眠后B进程在运行，当磁盘写完后磁盘中断信号打断的是B进程，在中断处理时会唤醒A进程。

进程上下文 VS 中断上下文
- 内核可以处于两种上下文：进程上下文和中断上下文。
- 在系统调用之后，用户应用程序进入内核空间，此后内核空间针对用户空间相应进程的代表就运行于进程上下文。
- 异步发生的中断会引发中断处理程序被调用，中断处理程序就运行于中断上下文。
- 中断上下文和进程上下文不可能同时发生。
- 运行于进程上下文的内核代码是可抢占的，但中断上下文则会一直运行至结束，不会被抢占。因此，<font color =red>**内核会限制中断上下文的工作**</font>，不允许其执行如下操作： 
- 1.进入睡眠状态或主动放弃CPU：由于中断上下文不属于任何进程，它与current没有任何关系（尽管此时current指向被中断的进程），所以中断上下文一旦睡眠或者放弃CPU，将无法被唤醒。所以也叫原子上下文（atomic context）。
- 2.占用互斥体：为了保护中断句柄临界区资源，不能使用mutexes。如果获得不到信号量，代码就会睡眠，会产生和上面相同的情况，如果必须使用锁，则使用spinlock。
- 3.执行耗时的任务：中断处理应该尽可能快，因为内核要响应大量服务和请求，中断上下文占用CPU时间太长会严重影响系统功能。在中断处理例程中执行耗时任务时，应该交由中断处理例程底半部来处理。
- 4.访问用户空间虚拟内存：因为中断上下文是和特定进程无关的，它是内核代表硬件运行在内核空间，所以在中断上下文无法访问用户空间的虚拟地址。
- 5.中断处理例程不应该设置成`reentrant`（可被并行或递归调用的例程）：因为中断发生时，`preempt`和`irq`都被`disable`，直到中断返回。所以中断上下文和进程上下文不一样，中断处理例程的不同实例，是不允许在SMP上并发运行的。
- 6.中断处理例程可以被更高级别的IRQ中断：如果想禁止这种中断，可以将中断处理例程定义成快速处理例程，相当于告诉CPU，该例程运行时，禁止本地CPU上所有中断请求。这直接导致的结果是，由于其他中断被延迟响应，系统性能下降。
<br>

原子上下文
- 内核的一个基本原则就是：在中断或者说原子上下文中，内核不能访问用户空间，而且内核是不能睡眠的。也就是说在这种情况下，内核是不能调用有可能引起睡眠的任何函数。一般来讲原子上下文指的是在中断或软中断中，以及在持有自旋锁的时候。内核提供 了四个宏来判断是否处于这几种情况里：
- 1.`#define in_irq() (hardirq_count())` 在处理硬中断中
- 2.`#define in_softirq() (softirq_count())` 在处理软中断中
- 3.`#define in_interrupt() (irq_count()) `在处理硬中断或软中断中
- 4.`#define in_atomic() ((preempt_count() & ~PREEMPT_ACTIVE) != 0)` 包含以上所有情况
- 这四个宏所访问的count都是thread_info->preempt_count。这个变量其实是一个位掩码。最低8位表示抢占计数，通常由`spin_lock/spin_unlock`修改，或程序员强制修改，同时表明内核容许的最大抢占深度是256。8－15位是软中断计数，通常由local_bh_disable/local_bh_enable修改，同时表明内核容许的最大软中断深度是256。16－27位是硬中断计数，通常由`enter_irq/exit_irq`修改，同时表明内核容许的最大硬中断深度是4096。第28位是`PREEMPT_ACTIVE`标志。

用代码表示就是：

```cpp
PREEMPT_MASK: 0x000000ff
SOFTIRQ_MASK: 0x0000ff00
HARDIRQ_MASK: 0x0fff0000
```

凡是上面4个宏返回1得到地方都是原子上下文，是不容许内核访问用户空间，不容许内核睡眠的，不容许调用任何可能引起睡眠的函数。而且代表`thread_info->preempt_count`不是0，这就告诉内核，在这里面抢占被禁用。

对于`in_atomic()`来说，在启用抢占的情况下，它工作的很好，可以告诉内核目前是否持有自旋锁，是否禁用抢占等。但是，在没有启用抢占的情况 下，`spin_lock`根本不修改`preempt_count`，所以即使内核调用了`spin_lock`，持有了自旋锁，`in_atomic()`仍然会返回 0，错误的告诉内核目前在非原子上下文中。**所以，凡是依赖`in_atomic()`来判断是否在原子上下文的代码，在禁抢占的情况下都是有问题的。**
<br>

## 编译与调试
**编译选项（gcc）**
1. -fsanitize = address 开启内存越界检测
2. -fsanitize-recover = address 一般开启后台程序为保证稳定性，不能遇到错就退出，而是继续运行，需要叠加设
3. 置ASAN_OPTIONS=halt_on_error=0 才会生效。
4.  cmake -DBUILD_TEST= ON ../ （-D是命令参数）， -D<var>[:<type>] = <value> : creat or update a cmake cache entry

gcov 是 Linux 下进行代码覆盖测试的工具
lcov 是 gcov的图形化前端工具，根据gcov生产的内容，处理一颗完整的html树，包括概括覆盖率百分比，图标等轻便直观内容。

**GDB调试**：
- ulimit -C unlimited 不限制 core 文件大小，再次运行二进制文件将生成core 文件。（编译时需要加"-g"才能生成可调试文件）
- gdb 文件名 core 生成core文件
- start 允许到 main函数，r 运行调试程序，s 单语句执行，n 单步执行，c 继续执行被调试程序直到下个断点。
- p <变量> 显示指定变量值，f 查看局部变量值(frame),选择栈号。
- b <函数名> 添加断点 ，info break 可以查看当前已经设置的断点， delete <断点编号>  删除断点，clear <行号> 删除对应行号的断点，disable <断点编号>  禁用断点。
- bt 输出堆栈信息，objdump -s xx.out 反汇编

cmakelist.txt : add_subdirectory(...) 将子目录添加到构筑中。

**踩内存**：对不属于你的内存进行读写
- 越界踩内存：1.申请/定义的内存小了 2. 栈溢出
- use after free/delete : 堆空间释放后又去使用这块内存（很可能该内存已经又被分配了出去）
- 随机踩内存

**魔术字**（magic number）：魔术字一般是指硬写到代码的整形常量数值，是编程者自己指定的，其他人不知道数值有什么具体意义。编程教程书用magic number指代初学者不定义常量直接写数的不良习惯。
- 使用情况：1.ELF文件头会写入一个magic number，检查这个数和自己预想的是否一致，可以判断文件是否损坏。2. 在缓冲区数组旁放一个magic number（称之canary金丝雀），通过检查是否一致可检测缓冲区溢出攻击。

断言（Assert）与 异常（exception）
- assert处理的是开发期的错误，在release代码上，由于你知道绝对不会发生的错误，但因为人总会犯错，保不准你写出来的与你想的不一致，assert用来捕获程序员自己认为不可能产生的错误。
- exception捕捉的是用户或环境可能引发的错误。
- 例如，一个函数入参有两个，而你只传递了一个，则是Assert，如果函数执行了以后，生成的执行结构异常，则用exception处理与理论不一致的情况。



# 算法
- 遗传算法： [跳转](https://www.jianshu.com/p/ae5157c26af9)


# 专业名词
```
Acronyms and abbreviations（缩略语）
AT （acceptance test）验收测试
BCC（Basic Conformance Class）基本一致性等级
BSW（Basic Software）基础软件
AutoSar（Automotive Open System Architecture）汽车开放系统架构
CI（Continuous instegration）持续集成
CRC (cyclic Redandancy check) 循环冗余校验
E2E（end to end） 测试流程（黑盒测试的一种）
ECC （Extended conformance clasee）扩展一致性等级
ECU（Electronic Control Unit）电子控制单元
EM （execution management）执行管理
FT （functional test）功能测试
HW（HardWare）硬件
IOC （Inter OS-Application communicator）应用程序通信器
ISR（Interrupted Service Routine）中断服务程序
IT （integration test）集成测试
LE（Locatable entity）可定位实体
MC（Multi-core）多核
MCU（Micro-controller Unit）微控制器
MMU（Memory Management Unit）内存管理单元
MPU（Memory Protection Unit）存储保护单元
OIL （OSEK Implementation Language）OSEK实施语言
OSA（Operating System Rountine）中断服务程序
OSEK（Open System and the corresponding interfances for automotive electronics）德国汽车电子类开放系统和对应接口标准
OSPF（Open Shortest PathFirst）开放式最短路径优先
PL - 项目组长 SE - 系统工程师 PG - 程序员 PM - 项目经理
Posix（portable operator system Interface）可以指操作系统接口
Pub（publisher）发布者，Sub（subscriber）订阅者
QM（质量标准证书）
ROS（Remote OPeration Service）远程操作服务
RPC（Remote Procedure Call）远程程序调用
RTE（Run-Time Environment）运行时环境
RTP（Real-Time Transport Protocol）实时传输协议（传输流媒体）
RTPS（Real-Time Programming System）实时编程系统
RTSP（Real-Time Transport control Protocol）实时传输控制协议（控制RTP）
DHCP（Dynamic Host Configuration Protocol）动态主机设置协议
SOAP（Simple Object Access Protocol）简单对象访问协议
SC（Single-core）单核
SLA（Software Layer Architecture）软件层架构                                                                                                                                                                                             
SR （service Router）业务路由器
ST （system test）系统测试 
SWC（Software component）软件组件
SWFRT（Software Free Running Timer）软件运行时
UT （Unit test）单元测试
VDE（Vehicule Distributed Executive）车载分布式执行器


奇偶校验码（parity bit / check bit）
海明校验码（Hamming Code）
```
